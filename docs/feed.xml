<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://oscarjiang.site/</id><title>姜鹏的博客</title><subtitle>分享金数据、浩客的故事，创业、管理、技术</subtitle> <updated>2023-02-14T22:18:56+08:00</updated> <author> <name>Oscar</name> <uri>https://oscarjiang.site/</uri> </author><link rel="self" type="application/atom+xml" href="https://oscarjiang.site/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://oscarjiang.site/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 Oscar </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>二十四分钟精通ClickHouse Materialized View</title><link href="https://oscarjiang.site/posts/master-clickhouse-mv.html/" rel="alternate" type="text/html" title="二十四分钟精通ClickHouse Materialized View" /><published>2023-02-12T00:00:00+08:00</published> <updated>2023-02-13T23:33:54+08:00</updated> <id>https://oscarjiang.site/posts/master-clickhouse-mv.html/</id> <content src="https://oscarjiang.site/posts/master-clickhouse-mv.html/" /> <author> <name>Oscar</name> </author> <category term="技术" /> <summary> ClickHouse是一个非常出色列数据库，对大数据量的实时分析有极佳的性能。本文用来介绍其MV（Materialized View，物化视图）的内部机制，帮助大家理解后更准确的使用。 文末takeway很重要! MV是一个trigger 定义MV，实际上定义了一个insert trigger。数据数据写入source table时，会根据配置分成多个block，MV从block中读取数据，写入MV对应的storage table中。 MV不会读取source table读取 调用一次insert时，MV select可能会被trigger多次 如下图，展示了数据写入时的情况 既然MV不从source table中读取，那极端情况如下图，当使用Null或者Kafka这样的Engine时，source table不会写入数据，但MV是可以存在的。 MV使用... </summary> </entry> <entry><title>「二次创业」的窘境</title><link href="https://oscarjiang.site/posts/second-startup.html/" rel="alternate" type="text/html" title="「二次创业」的窘境" /><published>2023-02-09T00:00:00+08:00</published> <updated>2023-02-09T00:00:00+08:00</updated> <id>https://oscarjiang.site/posts/second-startup.html/</id> <content src="https://oscarjiang.site/posts/second-startup.html/" /> <author> <name>Oscar</name> </author> <category term="管理" /> <summary> 《创新者的窘境》一书提到一种现象：一个运营良好的企业，有充分的客户基础，他们倾听客户声音，不断增强产品，但却最终倒闭。听起来似乎不合理，但却真实的发生。 过去一段时间，我们以「二次创业」的形式，上线了新产品 浩客。在已经有了金数据从零到千万用户的经验之上，整个过程应该要比较顺利才对，但还是经历了不少的的磨合与反复，还是值得思考。 借用该书的名称，这也许就是「二次创业」的窘境。 依赖的惯性 设计师依赖产品经理给出Lo-Fi 研发依赖产品经理出详细的AC 研发依赖设计师给出Hi-Fi 从角色上划分来看，上面的依赖十分正常，也是该角色该做的产出。 但是在初创阶段，特别是整个产品的基础框架已经上线后，这种依赖不会带来更大的收益，反而可能会是前进的阻碍。 产品经理要关注客户需求 创业不是交付产品，而是帮助用户完成他的工作。此时产品经理的关注点更多应是客户的使用情... </summary> </entry> <entry><title>重视贡献，为成果而工作</title><link href="https://oscarjiang.site/posts/focus-on-contribution.html/" rel="alternate" type="text/html" title="重视贡献，为成果而工作" /><published>2023-01-29T00:00:00+08:00</published> <updated>2023-01-29T23:37:28+08:00</updated> <id>https://oscarjiang.site/posts/focus-on-contribution.html/</id> <content src="https://oscarjiang.site/posts/focus-on-contribution.html/" /> <author> <name>Oscar</name> </author> <category term="管理" /> <summary> 有效的管理者重视对外界的贡献。他们并非为工作而工作，而是为成果而工作。 提出“我能做出什么贡献”的问题，是为了挖掘工作中尚未发挥的潜力。事实上许多工作看起来成绩辉煌，但是与潜在的贡献比起来，实在是微不足道。 重视贡献，才能使管理者的注意力不为其本身的专长所限，不为其本身的技术所限，不为其本身所属的部门所限，才能看到整体的绩效，同时也才能使他更加重视外部世界。只有外部世界才是产生成果的地方。 —— 彼得·德鲁克 《卓有成效的管理者》 成果带来价值 考虑如下场景： 产品经理组织一个showcase，向市场、销售、客服等业务部门介绍准备上线的功能。大家都很兴奋，针对功能的细节展开激烈的讨论。接下来他综合大家的反馈，进行优化调整，并最终部署上线。 这是日常迭代开发中一个非常普通的环节，通过内部演示，一方面周知不同团队新的功能，一方面收集更多的反馈以避免大面积... </summary> </entry> <entry><title>为什么Turbolinks发送了两次请求</title><link href="https://oscarjiang.site/posts/turbolinks-request-twice.html/" rel="alternate" type="text/html" title="为什么Turbolinks发送了两次请求" /><published>2015-01-22T00:00:00+08:00</published> <updated>2023-01-29T23:37:28+08:00</updated> <id>https://oscarjiang.site/posts/turbolinks-request-twice.html/</id> <content src="https://oscarjiang.site/posts/turbolinks-request-twice.html/" /> <author> <name>Oscar</name> </author> <category term="技术" /> <summary> 前面有一篇文章介绍过使用Turbolinks遇到的一个问题，最近又发现了另一个问题。 开发时，tail后台的log会发现某些情况下，同一个请求会触发两次，不过因为都是get请求，而且同一个地址请求后的响应式相同的，所以前台不能完全察觉到。不够下面的场景跟预期就不一致了。 假设需要一个功能可以在后台管理页面禁止用户账户，被禁止的账户在随后的所有访问当会重定向到禁止页面。 从实现上来讲，当判断出用户的禁用状态后，就会清除他的登录session，然后重定向到禁止页面。但是现象是用户会直接跳转到登录页面，当重新登陆后，则看到禁止页。查看后台就发现同一个地址请求了两次，第一次清除了session，第二次再访问因为没有session就转向到登陆页面了。 当然这种问题看看源码就清楚了，从Turbolinks的代码可以看出，在三种情况下，Turbolinks会尝试第二次请求同一个url。 ... </summary> </entry> <entry><title>Elasticsearch--更新策略</title><link href="https://oscarjiang.site/posts/elasticsearch-update-strategy.html/" rel="alternate" type="text/html" title="Elasticsearch--更新策略" /><published>2014-11-25T00:00:00+08:00</published> <updated>2023-01-29T23:37:28+08:00</updated> <id>https://oscarjiang.site/posts/elasticsearch-update-strategy.html/</id> <content src="https://oscarjiang.site/posts/elasticsearch-update-strategy.html/" /> <author> <name>Oscar</name> </author> <category term="技术" /> <summary> 前一篇文章介绍了如何在Elasticsearch上做动态映射，这篇文章会介绍下如何更有效的做ES的数据更新。 更新频率 如果把ES看做另一个数据库，那么它总是会比系统原有的数据库滞后，因为数据会先存入原有数据库，再同步到ES。那么滞后的时间就是一个敏感的参数。根据业务的不同，差别很大。我了解到有的系统可以接受10分钟以上的延迟，不过我们作为一个数据平台，用户提交或修改数据后，是希望能立刻查询到修改的结果的，所以理论上是越短越好，但频繁的更新会给ES服务器带来很大的开销。 异步更新 更新可以采用同步和异步两种方式。 同步： 使用elasticsearch-rails这个gem中的Automatic-Callback ，在inlcudeElasticsearch::Model::Callbacks后，实际上就是在每一次数据增删改后使用callback来往ES发送请求... </summary> </entry> </feed>
